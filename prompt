Ehh, a few issues before making the wiki proper.

First, we should definitely have a method of storing URLs that contain spoilers. The form to submit this is kinda the core of the application.

I propose the process would go as follows:
1. User enters URL into form
2. User can select from a dropdown of all media in the database
    2a. If the media is not in the database, the user can add it, this will bring up the media/new form. 
        2aa. If this is successfully added, the user is redirected back to the spoiler/new form, with the new media selected.

3. Once a media is selected, users can select a spoiler attached to said media. 
    3a. If the spoiler is not in the database, the user can add it, this will bring up the spoiler/new form. 
        3aa. If this is successfully added, the user is redirected back to the spoiler/new form, with the new spoiler selected.

4. The user then submits the URL, and it is added to the database.

Editing URLs follows this same ("if we dont have it, add it") process. Viewing a list of URLs has a tree structure incase there are multiple URLs for a single spoiler, and a list of all URLs for a single spoiler.

E.g it may look something like

Media1
├───Spoiler1(Intensity)
│   ├───URL1
│   └───URL2
├───Spoiler2(Intensity)
│   ├───URL3
└───Spoiler3(Intensity)
    └───URL4

Viewing an individual URL will show the URL, the spoiler it is attached to (and it's intensity), and the media it spoils.
URLs will also have an optional description field on "how" the media spoils it, for example, if the URL is a video, the description could be the timestamp of the spoiler.

Deleting a URL is nothing fancy, just a delete button next to each URL.

Please provide an overview of how you'll implement this URL system, but this time provide all the files and their code for me to simply copy and paste into the project (as opposed to going bit by bit).
================================================
To help you debug it, here's every changed/new file I've made since finalising basic spoiler CRUD:
app.js:
const express = require('express');
const bodyParser = require('body-parser');
const expressLayouts = require('express-ejs-layouts');
const methodOverride = require('method-override');
const path = require('path');

const mediaRoutes = require('./routes/media');
const spoilerRoutes = require('./routes/spoiler');
const URLRoutes = require('./routes/urls');

const app = express();

// Set up EJS as our templating engine
app.set('view engine', 'ejs');

// Set views directory
app.set('views', path.join(__dirname, 'views'));

// Set up express-ejs-layouts
app.use(expressLayouts);

// Set the layout file
app.set('layout', 'layout');

// Set up body-parser to parse form data
app.use(bodyParser.urlencoded({ extended: false }));

// Set up method-override to allow PUT and DELETE requests to be sent via POST
app.use(methodOverride('_method'));

// Set up a test route
app.get('/', (req, res) => {
  res.send('Hello, world!');
});

// Set up our media routes
app.use('/media', mediaRoutes);

// Set up our spoiler routes
app.use('/spoilers', spoilerRoutes);

// Set up our URL routes
app.use('/urls', URLRoutes);

// Start the server
app.listen(3000, () => {
  console.log('Server is running on port 3000');
});

const mongoose = require('mongoose');

mongoose.connect('mongodb://127.0.0.1:27017/spoilers_wiki', {
  useNewUrlParser: true,
  useUnifiedTopology: true,
  serverSelectionTimeoutMS: 5000, // Timeout after 5s instead of 30s
  socketTimeoutMS: 45000, // Close sockets after 45 seconds of inactivity
  keepAlive: true,
})
.then(() => console.log('Connected to MongoDB'))
.catch(err => console.error('Could not connect to MongoDB:', err));

/* 
const db = mongoose.connection;
db.on('error', (error) => console.error(error));
db.once('open', () => console.log('Connected to database'));
 */

models/URL.js:
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const URLSchema = new Schema({
  url: { type: String, required: true },
  media: { type: Schema.Types.ObjectId, ref: 'Media', required: true },
  spoiler: { type: Schema.Types.ObjectId, ref: 'Spoiler', required: true },
  description: { type: String }
});

module.exports = mongoose.model('URL', URLSchema);

routes/urls.js:
const express = require('express');
const router = express.Router();
const URL = require('../models/URL');
const Media = require('../models/Media');
const Spoiler = require('../models/Spoiler');

// New URL form
router.get('/new', async (req, res) => {
  const media = await Media.find({});
  const spoilers = await Spoiler.find({});
  res.render('urls/new', { media, spoilers });
});

// Create URL
router.post('/', async (req, res) => {
  const url = new URL(req.body);
  await url.save();
  res.redirect('/urls');
});

// Edit URL form
router.get('/:id/edit', async (req, res) => {
  const url = await URL.findById(req.params.id);
  const media = await Media.find({});
  const spoilers = await Spoiler.find({});
  res.render('urls/edit', { url, media, spoilers });
});

// Update URL
router.put('/:id', async (req, res) => {
  await URL.findByIdAndUpdate(req.params.id, req.body);
  res.redirect('/urls');
});

// Delete URL
router.delete('/:id', async (req, res) => {
  await URL.findByIdAndDelete(req.params.id);
  res.redirect('/urls');
});

// List URLs
router.get('/', async (req, res) => {
  const urls = await URL.find({}).populate('media').populate('spoiler');
  res.render('urls/index', { urls });
});

// Show URL
router.get('/:id', async (req, res) => {
  const url = await URL.findById(req.params.id).populate('media').populate('spoiler');
  res.render('urls/show', { url });
});

module.exports = router;

views/urls/new.ejs:
<!DOCTYPE html>
<html>
<head>
    <title>New URL</title>
</head>
<body>
    <h1>New URL</h1>
    <form action="/urls" method="post">
        <label for="url">URL</label>
        <input type="text" id="url" name="url" required>
      
        <label for="media">Media</label>
        <select id="media" name="media" required>
          <% media.forEach(medium => { %>
            <option value="<%= medium._id %>"><%= medium.title %></option>
          <% }); %>
        </select>
      
        <label for="spoiler">Spoiler</label>
        <select id="spoiler" name="spoiler" required>
          <% spoilers.forEach(spoiler => { %>
            <option value="<%= spoiler._id %>"><%= spoiler.description %></option>
          <% }); %>
        </select>
      
        <label for="description">Description (optional)</label>
        <textarea id="description" name="description"></textarea>
      
        <button type="submit">Create URL</button>
    </form>
</body>
</html>
  
views/urls/edit.ejs:
<!DOCTYPE html>
<html>
<head>
    <title>Edit URL</title>
</head>
<body>
    <form action="/urls/<%= url._id %>?_method=PUT" method="post">
        <label for="url">URL</label>
        <input type="text" id="url" name="url" value="<%= url.url %>" required>
      
        <label for="media">Media</label>
        <select id="media" name="media" required>
          <% media.forEach(medium => { %>
            <option value="<%= medium._id %>" <% if(medium._id.toString() === url.media._id.toString()) { %>selected<% } %>><%= medium.title %></option>
          <% }); %>
        </select>
      
        <label for="spoiler">Spoiler</label>
        <select id="spoiler" name="spoiler" required>
          <% spoilers.forEach(spoiler => { %>
            <option value="<%= spoiler._id %>" <% if(spoiler._id.toString() === url.spoiler._id.toString()) { %>selected<% } %>><%= spoiler.description %></option>
          <% }); %>
        </select>
      
        <label for="description">Description (optional)</label>
        <textarea id="description" name="description"><%= url.description %></textarea>
      
        <button type="submit">Update URL</button>
    </form>      
</body>
</html>

views/urls/show.ejs:
<!DOCTYPE html>
<html>
<head>
    <title>URLs</title>
</head>
<body>
    <h1><%= url.url %></h1>

    <h2>Media: <%= url.media.title %></h2>

    <h2>Spoiler: <%= url.spoiler.description %></h2>

    <h2>Description: <%= url.description || 'N/A' %></h2>

    <a href="/urls/<%= url._id %>/edit">Edit</a>
    <form action="/urls/<%= url._id %>?_method=DELETE" method="post">
        <button type="submit">Delete</button>
    </form>
</body>
</html>

views/urls/index.ejs:
<h1>All URLs</h1>

<% urls.forEach(url => { %>
  <h2><a href="/urls/<%= url._id %>"><%= url.url %></a></h2>

  <p>Media: <%= url.media.title %></p>

  <p>Spoiler: <%= url.spoiler.description %></p>

  <p>Description: <%= url.description || 'N/A' %></p>
<% }); %>

<a href="/urls/new">Add new URL</a>


Based on this information, can you help me diagnose the problem?
=================================================================================================
Brilliant stuff! Spoiler CRUD functionality is now working.
I have got an idea for how I want the base page to look - the base page being the one accessed on localhost:3000, just so I can get this finished before starting the wiki fr.
I want it to look like this example:

Spoiler Wiki
ADD: [Media] [Spoiler] [URL]

List of titles: ├─└
Media1 (Type) [Edit] [Delete]
├───Spoiler1(Intensity)
│   ├───URL1
│   └───URL2
├───Spoiler2(Intensity)
│   ├───URL3
└───Spoiler3(Intensity)
    └───URL4
Media2 (Type) [Edit] [Delete]
├───Spoiler4(Intensity)
│   ├───URL5
│   └───URL6
├───Spoiler5(Intensity)
│   ├───URL7

etc etc
Every Media, Spoiler, and URL will be a hyperlink to the show page for that item. The [buttons] are marked with brackets and are clickable, and the ├─└ are to show the tree structure.

How would I achieve this? Please provide each step in the process, and the code for each step.
=================================================================================================
<!DOCTYPE html>
<html>
<head>
  <title>Spoiler Wiki</title>
</head>
<body>
  <h1>Spoiler Wiki</h1>
  <a href="/media/new">[Media]</a>
  <a href="/spoilers/new">[Spoiler]</a>
  <a href="/urls/new">[URL]</a>
  <% mediaList.forEach(media => { %>
    <p>
      <a href="/media/<%= media._id %>"><%= media.title %></a> (<%= media.type %>)
      <a href="/media/<%= media._id %>/edit">[Edit]</a>
      <a href="/media/<%= media._id %>/delete">[Delete]</a>
    </p>
    <% media.spoilers.forEach(spoiler => { %>
      <p style="margin-left: 20px;">
        ├───<a href="/spoilers/<%= spoiler._id %>"><%= spoiler.title %></a>(<%= spoiler.intensity %>)
      </p>
      <% spoiler.urls.forEach(url => { %>
        <p style="margin-left: 40px;">
          ├───<a href="/urls/<%= url._id %>"><%= url.url %></a>
        </p>
      <% }) %>
      <p style="margin-left: 20px;">└───</p>
    <% }) %>
    <p>└───</p>
  <% }) %>
</body>
</html>
=================================================================================================
Right, lets get to the bottom of this. I've currently got the following error with my configuration:
(node:24176) UnhandledPromiseRejectionWarning: ReferenceError: Media is not defined
    at D:\School\Misc\spoilers\app.js:36:21
    at Layer.handle [as handle_request] (D:\School\Misc\spoilers\node_modules\express\lib\router\layer.js:95:5)
    at next (D:\School\Misc\spoilers\node_modules\express\lib\router\route.js:144:13)
    at Route.dispatch (D:\School\Misc\spoilers\node_modules\express\lib\router\route.js:114:3)
    at Layer.handle [as handle_request] (D:\School\Misc\spoilers\node_modules\express\lib\router\layer.js:95:5)
    at D:\School\Misc\spoilers\node_modules\express\lib\router\index.js:284:15
    at Function.process_params (D:\School\Misc\spoilers\node_modules\express\lib\router\index.js:346:12)       
    at next (D:\School\Misc\spoilers\node_modules\express\lib\router\index.js:280:10)
    at methodOverride (D:\School\Misc\spoilers\node_modules\method-override\index.js:65:14)
    at Layer.handle [as handle_request] (D:\School\Misc\spoilers\node_modules\express\lib\router\layer.js:95:5)
(node:24176) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 1)
(node:24176) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.

Here's the code for the files I believe to be relevant to this error:
app.js:
const express = require('express');
const bodyParser = require('body-parser');
const expressLayouts = require('express-ejs-layouts');
const methodOverride = require('method-override');
const path = require('path');

const mediaRoutes = require('./routes/media');
const spoilerRoutes = require('./routes/spoiler');
const URLRoutes = require('./routes/urls');

const app = express();

// Set up EJS as our templating engine
app.set('view engine', 'ejs');

// Set views directory
app.set('views', path.join(__dirname, 'views'));

// Set up express-ejs-layouts
app.use(expressLayouts);

// Set the layout file
app.set('layout', 'layout');

// Set up body-parser to parse form data
app.use(bodyParser.urlencoded({ extended: false }));

// Set up method-override to allow PUT and DELETE requests to be sent via POST
app.use(methodOverride('_method'));

// Set up backup title incase we forget to pass once
app.locals.title = 'NO TITLE SET';

// Set up our home route
app.get('/', async (req, res) => {
  const mediaList = await Media.find().populate('type').exec();
  res.render('index', { title: 'Spoiler Wiki', mediaList });
});

// Set up our media routes
app.use('/media', mediaRoutes);

// Set up our spoiler routes
app.use('/spoilers', spoilerRoutes);

// Set up our URL routes
app.use('/urls', URLRoutes);

// Start the server
app.listen(3000, () => {
  console.log('Server is running on port 3000');
});

const mongoose = require('mongoose');

mongoose.connect('mongodb://127.0.0.1:27017/spoilers_wiki', {
  useNewUrlParser: true,
  useUnifiedTopology: true,
  serverSelectionTimeoutMS: 5000, // Timeout after 5s instead of 30s
  socketTimeoutMS: 45000, // Close sockets after 45 seconds of inactivity
  keepAlive: true,
})
.then(() => console.log('Connected to MongoDB'))
.catch(err => console.error('Could not connect to MongoDB:', err));

/* 
const db = mongoose.connection;
db.on('error', (error) => console.error(error));
db.once('open', () => console.log('Connected to database'));
 */


views/index.ejs:
<!DOCTYPE html>
<html>
<head>
  <title>Spoiler Wiki</title>
</head>
<body>
  <h1>Spoiler Wiki</h1>
  <a href="/media/new">[Media]</a>
  <a href="/spoilers/new">[Spoiler]</a>
  <a href="/urls/new">[URL]</a>
  <% mediaList.forEach(media => { %>
    <p>
      <a href="/media/<%= media._id %>"><%= media.title %></a> (<%= media.type %>)
      <a href="/media/<%= media._id %>/edit">[Edit]</a>
      <a href="/media/<%= media._id %>/delete">[Delete]</a>
    </p>
    <% media.spoilers.forEach(spoiler => { %>
      <p style="margin-left: 20px;">
        ├───<a href="/spoilers/<%= spoiler._id %>"><%= spoiler.title %></a>(<%= spoiler.intensity %>)
      </p>
      <% spoiler.urls.forEach(url => { %>
        <p style="margin-left: 40px;">
          ├───<a href="/urls/<%= url._id %>"><%= url.url %></a>
        </p>
      <% }) %>
      <p style="margin-left: 20px;">└───</p>
    <% }) %>
    <p>└───</p>
  <% }) %>
</body>
</html>


models/media.js:
const mongoose = require('mongoose');

const mediaSchema = new mongoose.Schema({
  title: String,
  type: { type: String, required: true, enum: ['Video Game', 'TV Show', 'Film', 'Book', 'Sporting Event', 'Other'] },
  spoilers: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Spoiler' }]
});

module.exports = mongoose.model('Media', mediaSchema);


models/spoiler.js:
const mongoose = require('mongoose');

const SpoilerSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true
  },
  intensity: {
    type: String,
    required: true,
    enum: ['No Spoilers', 'Story Beats/Mild Spoilers', 'Major Spoilers']
  },
  reference: {
    type: String,
    required: true
  },
  media: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Media'
  }
});

module.exports = mongoose.model('Spoiler', SpoilerSchema);


routes/media.js:
const express = require('express');
const router = express.Router();
const Media = require('../models/media');

router.get('/', async (req, res) => {
  const mediaList = await Media.find({});
  res.render('media/index', { media: mediaList, title: 'Media List' });
});

router.get('/new', (req, res) => {
  res.render('media/new', { title: 'Add New Media' });
});

router.get('/:id/edit', async (req, res) => {
  try {
    const mediaItem = await Media.findById(req.params.id);
    res.render('media/edit', { media: mediaItem, title: `Edit ${mediaItem.title}` });
  } catch (err) {
    console.log(err);
    res.redirect('/media');
  }
});

router.get('/:id', async (req, res) => {
  try {
    const mediaItem = await Media.findById(req.params.id);
    res.render('media/show', { media: mediaItem, title: mediaItem.title });
    console.log("Success");
  } catch (err) {
    console.log(err);
    res.redirect('/media');
  }
});

router.post('/', async (req, res) => {
  const newMedia = new Media({
    title: req.body.title,
    type: req.body.type,
  });
  await newMedia.save();
  res.redirect('/media');
});

router.delete('/:id', async (req, res) => {
  try {
    await Media.findByIdAndRemove(req.params.id);
    res.redirect('/media');
  } catch (err) {
    console.log(err);
    res.redirect('/media');
  }
});


router.put('/:id', async (req, res) => {
  try {
    let mediaItem = await Media.findById(req.params.id);
    mediaItem.title = req.body.title;
    mediaItem.type = req.body.type;
    await mediaItem.save();
    res.redirect(`/media/${mediaItem.id}`);
  } catch (err) {
    console.log(err);
    res.redirect('/media');
  }
});

module.exports = router;


routes/spoiler.js:
const express = require('express');
const router = express.Router();
const Spoiler = require('../models/spoiler');
const Media = require('../models/media');

// Get all spoilers
router.get('/', async (req, res) => {
  try {
      const spoilersList = await Spoiler.find({}).populate('media');
      res.render('spoilers/index', { spoilers: spoilersList, title: 'Spoilers List' });
  } catch(err) {
      console.log(err);
      res.redirect('/spoilers');
  }
});

// Get spoilers by media ID
router.get('/media/:mediaId', async (req, res) => {
  const spoilers = await Spoiler.find({ media: req.params.mediaId });
  res.json(spoilers);
});

// New spoiler form
router.get('/new', async (req, res) => {
  try {
      const mediaList = await Media.find({});
      res.render('spoilers/new', { mediaList: mediaList, title: 'Create Spoiler' });
  } catch (err) {
      console.log(err);
      res.redirect('/spoilers');
  }
});

// Get the spoiler edit form
router.get('/:id/edit', async (req, res) => {
  try {
      const spoiler = await Spoiler.findById(req.params.id).populate('media');
      const mediaList = await Media.find({});
      res.render('spoilers/edit', { spoiler, mediaList, title: 'Edit Spoiler' });
  } catch (err) {
      console.log(err);
      res.redirect('/spoilers');
  }
});
  
// Get a single spoiler
router.get('/:id', async (req, res) => {
    try {
        const spoiler = await Spoiler.findById(req.params.id);
        res.render('spoilers/show', { spoiler, title: spoiler.title });
    } catch (err) {
        console.log(err);
        res.redirect('/spoilers');
    }
});

// Create a new spoiler
router.post('/', async (req, res) => {
  const newSpoiler = new Spoiler({
      title: req.body.title,
      intensity: req.body.intensity,
      reference: req.body.reference,
      media: req.body.mediaId
  });
  try {
      await newSpoiler.save();
      await Media.updateOne(
        { _id: req.body.mediaId },
        { $push: { spoilers: newSpoiler._id } }
      )
      res.redirect('/spoilers');
  } catch (err) {
      console.log(err);
      res.redirect('/spoilers/new');
  }
});

// Update a spoiler
router.put('/:id', async (req, res) => {
    try {
      let spoiler = await Spoiler.findById(req.params.id);
      spoiler.title = req.body.title;
      spoiler.intensity = req.body.intensity;
      spoiler.reference = req.body.reference;
      spoiler.media = req.body.mediaId;
      await spoiler.save();
      res.redirect(`/spoilers/${spoiler.id}`);
    } catch (err) {
      console.log(err);
      res.redirect('/spoilers');
    }
});
  
// Delete a spoiler
router.delete('/:id', async (req, res) => {
    try {
      await Spoiler.findByIdAndRemove(req.params.id);
      res.redirect('/spoilers');
    } catch (err) {
      console.log(err);
      res.redirect('/spoilers');
    }
  });
  
module.exports = router;


routes/urls.js:
const express = require('express');
const mongoose = require('mongoose');

const router = express.Router();
const URL = require('../models/URL');
const Media = mongoose.model('Media');
const Spoiler = mongoose.model('Spoiler');

// New URL form
router.get('/new', async (req, res) => {
  const media = await Media.find({});
  const spoilers = await Spoiler.find({});
  res.render('urls/new', { media, spoilers });
});

// Create URL
router.post('/', async (req, res) => {
  const url = new URL(req.body);
  await url.save();
  res.redirect('/urls');
});

// Edit URL form
router.get('/:id/edit', async (req, res) => {
  const url = await URL.findById(req.params.id);
  const media = await Media.find({});
  const spoilers = await Spoiler.find({});
  res.render('urls/edit', { url, media, spoilers });
});

// Update URL
router.put('/:id', async (req, res) => {
  await URL.findByIdAndUpdate(req.params.id, req.body);
  res.redirect('/urls');
});

// Delete URL
router.delete('/:id', async (req, res) => {
  await URL.findByIdAndDelete(req.params.id);
  res.redirect('/urls');
});

// List URLs
router.get('/', async (req, res) => {
  const urls = await URL.find({}).populate('media').populate('spoiler');
  res.render('urls/index', { urls, title: 'URLs' });
});

// Show URL
router.get('/:id', async (req, res) => {
  const url = await URL.findById(req.params.id).populate('media').populate('spoiler');
  res.render('urls/show', { url });
});

module.exports = router;


Please provide the fix for the error, and then provide all the changes necessary to get localhost:300 looking like the example.
=================================================================================================
Could you provide the full code for routes/urls.js, routes/spoiler.js, and routes/media.js? I'm not sure where to put this backreferencing for each bit.

As a refresher, here's the code for each file:-

routes/urls.js:
const express = require('express');
const mongoose = require('mongoose');

const router = express.Router();
const URL = require('../models/URL');
const Media = mongoose.model('Media');
const Spoiler = mongoose.model('Spoiler');

// New URL form
router.get('/new', async (req, res) => {
  const media = await Media.find({});
  const spoilers = await Spoiler.find({});
  res.render('urls/new', { media, spoilers });
});

// Create URL
router.post('/', async (req, res) => {
  const url = new URL(req.body);
  await url.save();
  res.redirect('/urls');
});

// Edit URL form
router.get('/:id/edit', async (req, res) => {
  const url = await URL.findById(req.params.id);
  const media = await Media.find({});
  const spoilers = await Spoiler.find({});
  res.render('urls/edit', { url, media, spoilers });
});

// Update URL
router.put('/:id', async (req, res) => {
  await URL.findByIdAndUpdate(req.params.id, req.body);
  res.redirect('/urls');
});

// Delete URL
router.delete('/:id', async (req, res) => {
  await URL.findByIdAndDelete(req.params.id);
  res.redirect('/urls');
});

// List URLs
router.get('/', async (req, res) => {
  const urls = await URL.find({}).populate('media').populate('spoiler');
  res.render('urls/index', { urls, title: 'URLs' });
});

// Show URL
router.get('/:id', async (req, res) => {
  const url = await URL.findById(req.params.id).populate('media').populate('spoiler');
  res.render('urls/show', { url });
});

module.exports = router;



routes/spoiler.js:
const express = require('express');
const router = express.Router();
const Spoiler = require('../models/spoiler');
const Media = require('../models/media');

// Get all spoilers
router.get('/', async (req, res) => {
  try {
      const spoilersList = await Spoiler.find({}).populate('media');
      res.render('spoilers/index', { spoilers: spoilersList, title: 'Spoilers List' });
  } catch(err) {
      console.log(err);
      res.redirect('/spoilers');
  }
});

// Get spoilers by media ID
router.get('/media/:mediaId', async (req, res) => {
  const spoilers = await Spoiler.find({ media: req.params.mediaId });
  res.json(spoilers);
});

// New spoiler form
router.get('/new', async (req, res) => {
  try {
      const mediaList = await Media.find({});
      res.render('spoilers/new', { mediaList: mediaList, title: 'Create Spoiler' });
  } catch (err) {
      console.log(err);
      res.redirect('/spoilers');
  }
});

// Get the spoiler edit form
router.get('/:id/edit', async (req, res) => {
  try {
      const spoiler = await Spoiler.findById(req.params.id).populate('media');
      const mediaList = await Media.find({});
      res.render('spoilers/edit', { spoiler, mediaList, title: 'Edit Spoiler' });
  } catch (err) {
      console.log(err);
      res.redirect('/spoilers');
  }
});
  
// Get a single spoiler
router.get('/:id', async (req, res) => {
    try {
        const spoiler = await Spoiler.findById(req.params.id);
        res.render('spoilers/show', { spoiler, title: spoiler.title });
    } catch (err) {
        console.log(err);
        res.redirect('/spoilers');
    }
});

// Create a new spoiler
router.post('/', async (req, res) => {
  const newSpoiler = new Spoiler({
      title: req.body.title,
      intensity: req.body.intensity,
      reference: req.body.reference,
      media: req.body.mediaId
  });
  try {
      await newSpoiler.save();
      await Media.updateOne(
        { _id: req.body.mediaId },
        { $push: { spoilers: newSpoiler._id } }
      )
      res.redirect('/spoilers');
  } catch (err) {
      console.log(err);
      res.redirect('/spoilers/new');
  }
});

// Update a spoiler
router.put('/:id', async (req, res) => {
    try {
      let spoiler = await Spoiler.findById(req.params.id);
      spoiler.title = req.body.title;
      spoiler.intensity = req.body.intensity;
      spoiler.reference = req.body.reference;
      spoiler.media = req.body.mediaId;
      await spoiler.save();
      res.redirect(`/spoilers/${spoiler.id}`);
    } catch (err) {
      console.log(err);
      res.redirect('/spoilers');
    }
});
  
// Delete a spoiler
router.delete('/:id', async (req, res) => {
    try {
      await Spoiler.findByIdAndRemove(req.params.id);
      res.redirect('/spoilers');
    } catch (err) {
      console.log(err);
      res.redirect('/spoilers');
    }
  });
  
module.exports = router;



const express = require('express');
const router = express.Router();
const Media = require('../models/media');

router.get('/', async (req, res) => {
  const mediaList = await Media.find({});
  res.render('media/index', { media: mediaList, title: 'Media List' });
});

router.get('/new', (req, res) => {
  res.render('media/new', { title: 'Add New Media' });
});

router.get('/:id/edit', async (req, res) => {
  try {
    const mediaItem = await Media.findById(req.params.id);
    res.render('media/edit', { media: mediaItem, title: `Edit ${mediaItem.title}` });
  } catch (err) {
    console.log(err);
    res.redirect('/media');
  }
});

router.get('/:id', async (req, res) => {
  try {
    const mediaItem = await Media.findById(req.params.id);
    res.render('media/show', { media: mediaItem, title: mediaItem.title });
    console.log("Success");
  } catch (err) {
    console.log(err);
    res.redirect('/media');
  }
});

router.post('/', async (req, res) => {
  const newMedia = new Media({
    title: req.body.title,
    type: req.body.type,
  });
  await newMedia.save();
  res.redirect('/media');
});

router.delete('/:id', async (req, res) => {
  try {
    await Media.findByIdAndRemove(req.params.id);
    res.redirect('/media');
  } catch (err) {
    console.log(err);
    res.redirect('/media');
  }
});


router.put('/:id', async (req, res) => {
  try {
    let mediaItem = await Media.findById(req.params.id);
    mediaItem.title = req.body.title;
    mediaItem.type = req.body.type;
    await mediaItem.save();
    res.redirect(`/media/${mediaItem.id}`);
  } catch (err) {
    console.log(err);
    res.redirect('/media');
  }
});

module.exports = router;

Please provide the updated code for each, pointing out what you've changed.
=================================================================================================
Wonderful. I can now populate my db with spoilers and URL's and theyre all collated here. One more request:

When showing the tree, currently it may look like this:
A
├───B
│   ├───C
│   └───D
└───E
    ├───F
    └───G

This "capping" of branches is nice, but only actually works if there's more than 2 children. In cases with only one or no children, it looks like this:

The Simpsons (TV Show) [Edit] [Delete]

└───

Of Mice and Men (Book) [Edit] [Delete]

    ├───George shoots Lenny(Major Spoilers)

        ├───https://en.wikipedia.org/wiki/Of_Mice_and_Men#Plot

    └───

└───

Here we can see 3 issues:
1. The Simpsons has no spoilers, yet still renders the "└───" branch
2. Of Mice and Men has one spoiler, yet still renders the "└───" branch to an empty space
3. The spoiler "George shoots Lenny" has one URL, yet incorrectly renders the "├───" branch instead of "└───"

I'll provide the code for views/index.ejs, and I'd like you to provide the code to fix these issues. Code:
<!DOCTYPE html>
<html>
<head>
  <title>Spoiler Wiki</title>
</head>
<body>
  <h1>Spoiler Wiki</h1>
  Add:
  <a href="/media/new">[Media]</a>
  <a href="/spoilers/new">[Spoiler]</a>
  <a href="/urls/new">[URL]</a>
  <% mediaList.forEach(media => { %>
    <p>
      <a href="/media/<%= media._id %>"><%= media.title %></a> (<%= media.type %>)
      <a href="/media/<%= media._id %>/edit">[Edit]</a>
      <a href="/media/<%= media._id %>/delete">[Delete]</a>
    </p>
    <% media.spoilers.forEach(spoiler => { %>
      <p style="margin-left: 20px;">
        ├───<a href="/spoilers/<%= spoiler._id %>"><%= spoiler.title %></a>(<%= spoiler.intensity %>)
      </p>
      <% spoiler.urls.forEach(url => { %>
        <p style="margin-left: 40px;">
          ├───<a href="/urls/<%= url._id %>"><%= url.url %></a>
        </p>
      <% }) %>
      <p style="margin-left: 20px;">└───</p>
    <% }) %>
    <p>└───</p>
  <% }) %>
</body>
</html>
=================================================================================================
Ok, that's all working. I've now got a new change to request for how media is handled. Currently, spoilers are just blindly attached to media, but I'd like to be able to seperate that media into parts/episodes/chapters/levels/etc.
Media doesn't have to have this; a film for example is intended to be watched in one sitting, so it doesn't need to be seperated into parts. But a TV show has episodes, a book has chapters, a game has levels, etc. I'd like to be able to add these to media, and then attach spoilers to those parts instead of the media itself. (Note: for TV shows, which have series, I don't want nested parts. The parts would simply go like "S1E1", "S1E2", "S1E3", "S2E1", "S2E2", etc.)
When adding a media, there'd be a tickbox saying something like:
"Does this media have parts?"
And if ticked, 2 new inputs would appear:
- A dropdown for selecting whether the game seperates it's content into chapters, levels, episodes, or parts. This would also have 2 extra options: one for a custom designator, and one for "no consitent designator". This defaults to chapters for books, episodes for TV shows, levels for games and no consistent designator for anything else.
- A number selector for the amount of parts in the media. Defaulted to 0 for clutter reasons as explained below.
Once these 2 inputs are filled, several small textboxes render underneath them. These will be the titles for the parts. The amount of textboxes rendered is equal to the number selected in the number selector (if 0, none are rendered, which is why by default this is set to 0). These textboxes can be edited by the user but default to the designator defined earlier. In the case of a Book with 5 chapters, the boxes would have their default value filled as follows:
- Chapter 1
- Chapter 2
- Chapter 3
- Chapter 4
- Chapter 5

This feature would also be available when editing media, and would be rendered in the same way as the textboxes are rendered when adding media. When viewing media, a list of all these parts are shown alongside the other content.

When adding a spoiler, the user can check a box that reads "Is this spoiler specific to any part?" and if checked, a dropdown appears showing all the parts of that media (this can also be done when editing a spoiler, to attach it to a part after adding it). The linked part is stored with the spoiler, and appears on it's show.ejs page.

Please describe all the changes that are required to implement this feature, and provide the code for each change.
=================================================================================================
Ok, I've changed the models/ and routes/ files.
Let's now work on the actual .ejs pages themselves. This will involve changes to all views in views/media and views/spoilers, as well as the index.ejs page in views/.

Let's first work on the media views. Remember, the main things that need to be introduced:
- A tickbox for "Does this media have parts?"
- A dropdown for selecting whether the game seperates it's content into chapters, levels, episodes, or parts. This would also have 2 extra options: one for a custom designator, and one for "no consitent designator". This defaults to chapters for books, episodes for TV shows, levels for games and no consistent designator for anything else.
- A number selector for the amount of parts in the media. Defaulted to 0 for clutter reasons as explained below.
- Several small textboxes render underneath them. These will be the titles for the parts. The amount of textboxes rendered is equal to the number selected in the number selector (if 0, none are rendered, which is why by default this is set to 0). These textboxes can be edited by the user but default to the designator defined earlier. In the case of a Book with 5 chapters, the boxes would have their default value filled as follows:
- Chapter 1
- Chapter 2
- Chapter 3
- Chapter 4
- Chapter 5

When viewing a media, a list of all these parts are shown alongside the other content. When viewing all media this is not visible, and for this reason I don't think it's necessary to edit the index.ejs page in views/ or views/media. If you think it is, please explain why.
We'll work on spoilers once this is all in place. For now, here's my existing code for:

views/media/new.ejs:
<h1>Add a new media</h1>

<form action="/media" method="post">
  <label for="title">Title</label>
  <input type="text" id="title" name="title">

  <label for="type">Type:</label>
  <select id="type" name="type">
    <option value="Video Game">Video Game</option>
    <option value="TV Show">TV Show</option>
    <option value="Film">Film</option>
    <option value="Book">Book</option>
    <option value="Sporting Event">Sporting Event</option>
    <option value="Other">Other</option>
  </select>

  <input type="submit" value="Submit">
</form>

views/media/edit.ejs:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= title %></title>
</head>
<body>
  <h1><%= title %></h1>

  <form action="/media/<%= media._id %>?_method=PUT" method="POST">
    <div>
      <label for="title">Title:</label>
      <input type="text" id="title" name="title" value="<%= media.title %>">
    </div>

    <div>
      <label for="type">Type:</label>
      <select id="type" name="type">
        <option value="Video Game" <%= media.type == 'Video Game' ? 'selected' : '' %>>Video Game</option>
        <option value="TV Show" <%= media.type == 'TV Show' ? 'selected' : '' %>>TV Show</option>
        <option value="Film" <%= media.type == 'Film' ? 'selected' : '' %>>Film</option>
        <option value="Book" <%= media.type == 'Book' ? 'selected' : '' %>>Book</option>
        <option value="Sporting Event" <%= media.type == 'Sporting Event' ? 'selected' : '' %>>Sporting Event</option>
        <option value="Other" <%= media.type == 'Other' ? 'selected' : '' %>>Other</option>
      </select>
    </div>

    <button type="submit">Update Media</button>
  </form>

  <a href="/media/<%= media._id %>">Cancel</a>
</body>
</html>

views/media/show.ejs:
<h1><%= media.title %></h1>
<p>Type: <%= media.type %></p>

<a href="/media">Back</a>
<a href="/media/<%= media._id %>/edit">Edit</a>
<form action="/media/<%= media._id %>?_method=DELETE" method="POST">
  <button type="submit">Delete</button>
</form>

Please provide the necessary additions to these files to implement the features described above.
=================================================================================================
Good start, but there's some issues and missing features from the form (I have not tested actually sending this data yet so more may be to follow):

- When the part designator is set to "custom", another box should appear. This will be used to apply the designator name to the parts. For example, if the designator is set to "custom" and the custom designator is set to "level", the parts will be called "Level 1", "Level 2", etc. This box should be hidden by default, and only appear when the designator is set to "custom".

- When the part designator is set to "None", the generated boxes should not have any text in them by default. Currently, they display "None 1", "None 2", etc.

-The boxes only update on changes to the "number of parts" box. This currently doesn't apply to anything else. This updating feature should be applied to both the "part designator" box and the "custom designator" box (that you haven't added yet).

-The hiding of the options based on the checkbox does not seem to be implemented at all in the edit form. This should be implemented.

Please make these changes to these files.
=================================================================================================
Great, think that's everything working now with regards to media. Now onto spoilers. When adding a spoiler to a media, the user can select a part from a dropdown list (for that media) to "attach" the spoiler to, or "Entire Media" if they so desire (this is the default). When viewing a spoiler, the part it is attached to is displayed alongside it. When viewing all spoilers, this is not displayed. When editing a spoiler, this option appears on this form too.

If a media has no parts attached to it, the list will only show "Entire Media".

On the index.ejs page for the localhost:3000, each of the rendered spoilers will display the part (in brackets) that it is attached to. If it is attached to the entire media, this will not be displayed.
On an individual spoilers show page, if there is a part it is attached to, this will be displayed alongside it. If it is attached to the entire media, this will not be displayed.

Here's the code for the following files, for reference:
models/spoiler.js:
const mongoose = require('mongoose');
const partSchema = require('./media').partSchema;

const SpoilerSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true
  },
  intensity: {
    type: String,
    required: true,
    enum: ['No Spoilers', 'Story Beats/Mild Spoilers', 'Major Spoilers']
  },
  reference: {
    type: String,
    required: true
  },
  media: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Media'
  },
  urls: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'URL'
  }]
});

module.exports = mongoose.model('Spoiler', SpoilerSchema);


routes/spoilers.js:
const express = require('express');
const router = express.Router();
const Spoiler = require('../models/spoiler');
const Media = require('../models/media');

// Get all spoilers
router.get('/', async (req, res) => {
  try {
      const spoilersList = await Spoiler.find({}).populate('media');
      res.render('spoilers/index', { spoilers: spoilersList, title: 'Spoilers List' });
  } catch(err) {
      console.log(err);
      res.redirect('/spoilers');
  }
});

// Get spoilers by media ID
router.get('/media/:mediaId', async (req, res) => {
  const spoilers = await Spoiler.find({ media: req.params.mediaId });
  res.json(spoilers);
});

// New spoiler form
router.get('/new', async (req, res) => {
  try {
      const mediaList = await Media.find({});
      res.render('spoilers/new', { mediaList: mediaList, title: 'Create Spoiler' });
  } catch (err) {
      console.log(err);
      res.redirect('/spoilers');
  }
});

// Get the spoiler edit form
router.get('/:id/edit', async (req, res) => {
  try {
      const spoiler = await Spoiler.findById(req.params.id).populate('media');
      const mediaList = await Media.find({});
      res.render('spoilers/edit', { spoiler, mediaList, title: 'Edit Spoiler' });
  } catch (err) {
      console.log(err);
      res.redirect('/spoilers');
  }
});
  
// Get a single spoiler
router.get('/:id', async (req, res) => {
    try {
        const spoiler = await Spoiler.findById(req.params.id);
        res.render('spoilers/show', { spoiler, title: spoiler.title });
    } catch (err) {
        console.log(err);
        res.redirect('/spoilers');
    }
});

// Create a new spoiler
router.post('/', async (req, res) => {
  const part = req.body.part ? { title: req.body.part } : null; // If a part was selected, create a part object

  const newSpoiler = new Spoiler({
    title: req.body.title,
    intensity: req.body.intensity,
    reference: req.body.reference,
    media: req.body.mediaId,
    part
  });

  try {
    await newSpoiler.save();
    await Media.updateOne(
      { _id: req.body.mediaId },
      { $push: { spoilers: newSpoiler._id } }
    )
    res.redirect('/spoilers');
  } catch (err) {
    console.log(err);
    res.redirect('/spoilers/new');
  }
});

// Update a spoiler
router.put('/:id', async (req, res) => {
  try {
    let spoiler = await Spoiler.findById(req.params.id);

    const part = req.body.part ? { title: req.body.part } : null; // If a part was selected, create a part object

    spoiler.title = req.body.title;
    spoiler.intensity = req.body.intensity;
    spoiler.reference = req.body.reference;
    spoiler.media = req.body.mediaId;
    spoiler.part = part;

    await spoiler.save();
    res.redirect(`/spoilers/${spoiler.id}`);
  } catch (err) {
    console.log(err);
    res.redirect('/spoilers');
  }
});
  
// Delete a spoiler
router.delete('/:id', async (req, res) => {
    try {
      await Spoiler.findByIdAndRemove(req.params.id);
      res.redirect('/spoilers');
    } catch (err) {
      console.log(err);
      res.redirect('/spoilers');
    }
  });
  
module.exports = router;


views/spoilers/new.ejs:
<!DOCTYPE html>
<html>
<head>
  <title>Add New Spoiler</title>
</head>
<body>
  <h1>Add New Spoiler</h1>
  <form action="/spoilers" method="post">
    <label for="title">Title:</label>
    <input type="text" id="title" name="title" required>

    <label for="intensity">Intensity:</label>
    <select id="intensity" name="intensity">
      <option value="No Spoilers">No Spoilers</option>
      <option value="Story Beats/Mild Spoilers">Story Beats/Mild Spoilers</option>
      <option value="Major Spoilers">Major Spoilers</option>
    </select><br>

    <label for="reference">Reference:</label>
    <input type="text" id="reference" name="reference">

    <label for="media">Media:</label>
    <select id="media" name="mediaId" required>
        <% mediaList.forEach(media => { %>
            <option value="<%= media._id %>"><%= media.title %></option>
        <% }); %>
    </select>

    <input type="submit" value="Create">
</form>

</body>
</html>


views/spoilers/edit.ejs:
<!DOCTYPE html>
<html>
<head>
  <title>Edit Spoiler</title>
</head>
<body>
  <h1>Edit Spoiler</h1>
  <form action="/spoilers/<%= spoiler._id %>?_method=PUT" method="POST">
    <label for="title">Title:</label><br>
    <input type="text" id="title" name="title" value="<%= spoiler.title %>"><br>
    <label for="intensity">Intensity:</label><br>
    <select id="intensity" name="intensity">
      <option value="No Spoilers" <% if (spoiler.intensity === 'No Spoilers') { %>selected<% } %>>No Spoilers</option>
      <option value="Story Beats/Mild Spoilers" <% if (spoiler.intensity === 'Story Beats/Mild Spoilers') { %>selected<% } %>>Story Beats/Mild Spoilers</option>
      <option value="Major Spoilers" <% if (spoiler.intensity === 'Major Spoilers') { %>selected<% } %>>Major Spoilers</option>
    </select><br>
    <label for="reference">Reference:</label><br>
    <input type="text" id="reference" name="reference" value="<%= spoiler.reference %>"><br>
    <input type="hidden" id="mediaId" name="mediaId" value="<%= spoiler.media._id %>"><br>
    <input type="submit" value="Submit">
  </form>
</body>
</html>


views/spoilers/show.ejs:
<!DOCTYPE html>
<html>
<head>
  <title><%= spoiler.title %></title>
</head>
<body>
  <h1><%= spoiler.title %></h1>
  <p>Intensity: <%= spoiler.intensity %></p>
  <p>Reference: <%= spoiler.reference %></p>
  <a href="/spoilers/<%= spoiler._id %>/edit">Edit</a>
  <form action="/spoilers/<%= spoiler._id %>?_method=DELETE" method="POST">
    <button type="submit">Delete</button>
  </form>
  <a href="/spoilers">Back</a>
</body>
</html>


Please describe and provide code for all of the changes needed.
=================================================================
ok, I implemented the get(/new) and get(/edit) routes, but your suggestions for the create and update routes confuse me. For reference, this is what I have originally in routes/spoilers.js:
// Create a new spoiler
router.post('/', async (req, res) => {
  const part = req.body.part ? { title: req.body.part } : null; // If a part was selected, create a part object

  const newSpoiler = new Spoiler({
    title: req.body.title,
    intensity: req.body.intensity,
    reference: req.body.reference,
    media: req.body.mediaId,
    part
  });

  try {
    await newSpoiler.save();
    await Media.updateOne(
      { _id: req.body.mediaId },
      { $push: { spoilers: newSpoiler._id } }
    )
    res.redirect('/spoilers');
  } catch (err) {
    console.log(err);
    res.redirect('/spoilers/new');
  }
});

// Update a spoiler
router.put('/:id', async (req, res) => {
  try {
    let spoiler = await Spoiler.findById(req.params.id);

    const part = req.body.part ? { title: req.body.part } : null; // If a part was selected, create a part object

    spoiler.title = req.body.title;
    spoiler.intensity = req.body.intensity;
    spoiler.reference = req.body.reference;
    spoiler.media = req.body.mediaId;
    spoiler.part = part;

    await spoiler.save();
    res.redirect(`/spoilers/${spoiler.id}`);
  } catch (err) {
    console.log(err);
    res.redirect('/spoilers');
  }
});

why do i need to change it to this like you suggested?:
// Create a new spoiler
router.post('/', async (req, res) => {
  const newSpoiler = new Spoiler({
    // ... other fields ...
    part: req.body.partId,
  });
  // ... rest of the route ...
});

// Update a spoiler
router.put('/:id', async (req, res) => {
  // ... before updating ...
  spoiler.part = req.body.partId;
  // ... rest of the route ...
});
=================================================================
Ok, that seems to work fine. Now let's get onto work for the views/spoilers .ejs files.

Here's the code for views/spoilers/new.ejs:
<!DOCTYPE html>
<html>
<head>
  <title>Add New Spoiler</title>
</head>
<body>
  <h1>Add New Spoiler</h1>
  <form action="/spoilers" method="post">
    <label for="title">Title:</label>
    <input type="text" id="title" name="title" required>

    <label for="intensity">Intensity:</label>
    <select id="intensity" name="intensity">
      <option value="No Spoilers">No Spoilers</option>
      <option value="Story Beats/Mild Spoilers">Story Beats/Mild Spoilers</option>
      <option value="Major Spoilers">Major Spoilers</option>
    </select><br>

    <label for="reference">Reference:</label>
    <input type="text" id="reference" name="reference">

    <label for="media">Media:</label>
    <select id="media" name="mediaId" required>
        <% mediaList.forEach(media => { %>
            <option value="<%= media._id %>"><%= media.title %></option>
        <% }); %>
    </select>

    <input type="submit" value="Create">
</form>

</body>
</html>

I want this page to show a box for attaching a spoiler to a part ONLY if the media selected has parts. This dropdown list will be generated from the media, and is defaulted to "Entire Media". If the media has no parts, this dropdown list will only show "Entire Media".

Here's the code for views/spoilers/edit.ejs:
<!DOCTYPE html>
<html>
<head>
  <title>Edit Spoiler</title>
</head>
<body>
  <h1>Edit Spoiler</h1>
  <form action="/spoilers/<%= spoiler._id %>?_method=PUT" method="POST">
    <label for="title">Title:</label><br>
    <input type="text" id="title" name="title" value="<%= spoiler.title %>"><br>
    <label for="intensity">Intensity:</label><br>
    <select id="intensity" name="intensity">
      <option value="No Spoilers" <% if (spoiler.intensity === 'No Spoilers') { %>selected<% } %>>No Spoilers</option>
      <option value="Story Beats/Mild Spoilers" <% if (spoiler.intensity === 'Story Beats/Mild Spoilers') { %>selected<% } %>>Story Beats/Mild Spoilers</option>
      <option value="Major Spoilers" <% if (spoiler.intensity === 'Major Spoilers') { %>selected<% } %>>Major Spoilers</option>
    </select><br>
    <label for="reference">Reference:</label><br>
    <input type="text" id="reference" name="reference" value="<%= spoiler.reference %>"><br>
    <input type="hidden" id="mediaId" name="mediaId" value="<%= spoiler.media._id %>"><br>
    <input type="submit" value="Submit">
  </form>
</body>
</html>

This is mostly the same change, but with the dropdown box defaulting to whatever part (or "Entire Media") the spoiler has already been set to. If for whatever reason the spoiler is not attached to a part, it defaults to entire media.

Please provide the code for the requested changes.
